---
# vim:set sw=2 ts=8 et fileencoding=utf8:
# SPDX-License-Identifier: BSD-2-Clause
# SPDX-FileCopyrightText: 2025 Сергей Леонтьев (leo@sai.msu.ru)
#
# Пример сборки, тестов и запуска для Clang, GNU, IntelLLVM, LCC, MSVC.
#
# Реализован путём минимальных доработок начального процесса от GitHub.
#
# LCC, MCST Elbrus, e2k использует https://github.com/mrognor/lcc-env-action.git
#
# IntelLLVM (oneAPI) по мотивам https://github.com/scivision/ffilesystem.git
#
# This starter workflow is for a CMake project running on multiple platforms.
# There is a different starter workflow if you just want a single platform.
# See:
# https://github.com/actions/starter-workflows/blob/main/ci/cmake-single-platform.yml

name: CMake on multiple platforms

on:  # yamllint disable-line rule:truthy
  push:
    branches: ["main", "lcc_*"]
  pull_request:
    branches: ["main", "lcc_*"]

jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      # Set fail-fast to false to ensure that feedback is delivered for all
      # matrix combinations. Consider changing this to true when your workflow
      # is stable.

      fail-fast: false

      # Set up a matrix to run the following 5 configurations:
      #
      # 1. <Latest MSVC compiler toolchain on the default runner image,
      # Windows, Release, default generator>
      #
      # 2. <Latest GCC compiler toolchain on the default runner image, Linux,
      # Release, default generator>
      #
      # 3. <Latest Clang compiler toolchain on the default runner image, Linux,
      # Release, default generator>
      #
      # 4. <oneAPI 2025.1, Linux, Release, default generator>
      #
      # 5. <LCC MCST Elbrus e2k, Linux, Release, default generator>
      #
      # To add more build types (Release, Debug, RelWithDebInfo, etc.)
      # customize the build_type list.

      matrix:
        c_compiler: [gcc, clang, cl, icx, lcc]
        os: [ubuntu-latest, windows-latest]
        build_type: [Release]
        include:
          - c_compiler: cl
            cpp_compiler: cl
            os: windows-latest
            platform: "win32"
          - c_compiler: gcc
            cpp_compiler: g++
            os: ubuntu-latest
            platform: "linux"
          - c_compiler: clang
            cpp_compiler: clang++
            os: ubuntu-latest
            platform: "linux"
          - c_compiler: icx
            cpp_compiler: icpx
            oneapi: 2025.1
            os: ubuntu-latest
            platform: "linux"
          - c_compiler: lcc
            cpp_compiler: l++
            lcc_dirname: lcc-1.29.12.e2k-v5.8c2.linux-6.1  # TODO:
            cross_emul: e2k
            cmake_add: >
              -DCMAKE_CROSSCOMPILING=ON -DCMAKE_SYSTEM_NAME=Generic-ELF
              -DCMAKE_CROSSCOMPILING_EMULATOR=e2k
            os: ubuntu-latest
            platform: "e2k"
        exclude:
          - os: windows-latest
            c_compiler: gcc
          - os: windows-latest
            c_compiler: clang
          - os: windows-latest
            c_compiler: icx
          - os: windows-latest
            c_compiler: lcc
          - os: ubuntu-latest
            c_compiler: cl

    steps:
      - uses: actions/checkout@v4

      - name: Cache install LCC MCST Elbrus e2k
        if: ${{ matrix.c_compiler == 'lcc' }}
        id: cache-lcc
        uses: actions/cache@v4
        with:
          path: |
            /opt/mcst
            /usr/local/bin/e2k
            /usr/local/bin/qemu-e2k
            /usr/local/bin/lcc
            /usr/local/bin/l++
          key: cache-${{ matrix.lcc_dirname }}-mrognor

      - name: Non-cache install LCC MCST Elbrus e2k
        if: ${{ matrix.c_compiler == 'lcc' &&
                steps.cache-lcc.outputs.cache-hit != 'true' }}
        timeout-minutes: 10
        uses: mrognor/lcc-env-action@0.1.1
        with:
          # TODO: matrix.lcc_dirname
          lcc_dirname: lcc-1.29.12.e2k-v5.8c2.linux-6.1
          lcc_tarname: cross-sp-1.29.12.e2k-v5.8c2.linux-6.1_64.tgz
          lcc_link: https://dev.mcst.ru/downloads/2025-06-27/cross-sp-1.29.12.e2k-v5.8c2.linux-6.1_64.tgz  # yamllint disable-line rule:line-length

      - name: e2k bug workaround
        if: ${{ matrix.c_compiler == 'lcc' }}
        run: |
          lcc_dirname=$(dirname $(readlink /usr/local/bin/lcc))/..
          echo "#!" > /usr/local/bin/e2k
          echo "qemu-e2k -L ${lcc_dirname}/fs -- \"\$@\"" >> /usr/local/bin/e2k

      - name: Cache install oneAPI
        if: ${{ matrix.c_compiler == 'icx' }}
        id: cache-icx
        uses: actions/cache@v4
        with:
          path: |
            /opt/intel/oneapi
          key: oneapi-${{ matrix.oneapi }}-apt

      - name: Non-cache install oneAPI
        if: ${{ matrix.c_compiler == 'icx' &&
                steps.cache-icx.outputs.cache-hit != 'true' }}
        timeout-minutes: 3
        run: |
          bash .github/workflows/oneapi_setup_apt_repo_linux.sh
          sudo apt install --no-install-recommends \
               intel-oneapi-compiler-dpcpp-cpp-${{ matrix.oneapi }}

      - name: Setup Intel oneAPI environment
        if: ${{ matrix.c_compiler == 'icx' }}
        run: |
          source /opt/intel/oneapi/setvars.sh
          printenv >> $GITHUB_ENV

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install python module
        run: |
          python -c "import sys; print(sys.version); print(sys.executable)"
          python -m pip install junitparser yamllint

      - name: Lint
        run: |
          python -m yamllint --list-file .
          python -m yamllint .

      - name: Set reusable strings
        # Turn repeated input strings (such as the build output directory) into
        # step outputs. These step outputs can be used throughout the workflow
        # file.

        id: strings
        shell: bash
        run: |
          echo "build-output-dir=${{ github.workspace }}/build" \
               >> "$GITHUB_OUTPUT"

      - name: Configure CMake
        # Configure CMake in a 'build' subdirectory. `CMAKE_BUILD_TYPE` is only
        # required if you are using a single-configuration generator such as
        # make.  See
        # https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html?highlight=cmake_build_type

        run: >
          cmake -B ${{ steps.strings.outputs.build-output-dir }}
          -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }}
          -DCMAKE_C_COMPILER=${{ matrix.c_compiler }}
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -S ${{ github.workspace }}
          ${{ matrix.cmake_add }}

      - name: Build
        # Build your program with the given configuration. Note that --config
        # is needed because the default Windows generator is a multi-config
        # generator (Visual Studio generator).

        run: >
          cmake --build ${{ steps.strings.outputs.build-output-dir }}
          --config ${{ matrix.build_type }}

      - name: Test
        working-directory: ${{ steps.strings.outputs.build-output-dir }}
        # Execute tests defined by the CMake configuration. Note that
        # --build-config is needed because the default Windows generator is a
        # multi-config generator (Visual Studio generator).  See
        # https://cmake.org/cmake/help/latest/manual/ctest.1.html for more
        # detail

        run: ctest --build-config ${{ matrix.build_type }}

      - name: Run Windows
        working-directory: ${{ steps.strings.outputs.build-output-dir }}
        if: ${{ matrix.platform == 'win32' }}
        run: |
          ${{ matrix.build_type }}\hello
          ${{ matrix.build_type }}\hello++
          ${{ matrix.build_type }}\bsd_echo my args

      - name: Run Linux
        working-directory: ${{ steps.strings.outputs.build-output-dir }}
        if: ${{ matrix.platform != 'win32' }}
        run: |
          for h in ./hello* ; do
            ${{ matrix.cross_emul}} $h
          done
          ${{ matrix.cross_emul}} ./bsd_echo* my args
